<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaceWeatherNow Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.x/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a2e; /* Dunkler Hintergrund */
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #00bcd4; /* Akzentfarbe */
            margin-bottom: 30px;
            font-size: 2.5em;
            text-align: center;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); /* Responsives Grid */
            gap: 20px;
            max-width: 1200px; /* Maximale Breite des Dashboards */
            width: 100%;
        }

        .card {
            background-color: #2e2e4a; /* Dunklere Karte */
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
        }

        .card h2 {
            color: #00bcd4; /* Akzentfarbe für Überschriften */
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.6em;
        }

        .icon {
            font-size: 3em;
            color: #ff9800; /* Orangener Akzent für Icons */
            margin-bottom: 15px;
        }

        .value {
            font-size: 2.8em;
            font-weight: bold;
            color: #4caf50; /* Grün für Werte */
            margin-bottom: 10px;
        }

        .unit {
            font-size: 1.1em;
            color: #a0a0a0;
        }

        .description {
            font-size: 0.9em;
            color: #b0b0b0;
            margin-top: 15px;
            line-height: 1.5;
        }
        .utc-notice {
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
        }


        .loading {
            color: #888;
            font-style: italic;
        }

        .error {
            color: #e57373;
            font-weight: bold;
        }

        canvas {
            background-color: #1e1e32;
            border-radius: 8px;
            margin-top: 15px;
            width: 100% !important; /* Wichtig für Chart.js in Flexbox */
            height: 200px; /* Feste Höhe für kleine Charts */
        }

        /* --- Modal für große Charts --- */
        .modal {
            display: none; /* Versteckt als Standard */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7); /* Dunkler, halbtransparenter Hintergrund */
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #2e2e4a;
            margin: auto;
            padding: 20px;
            border: 1px solid #4a4a6e;
            border-radius: 12px;
            width: 80%;
            max-width: 900px;
            position: relative;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {opacity: 0;}
            to {opacity: 1;}
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: #fff;
            text-decoration: none;
            cursor: pointer;
        }

        .modal-chart-container {
            width: 100%;
            height: 400px; /* Höhe für das große Chart */
            margin-top: 20px;
        }

        /* Time selector container is now empty */
        .time-selector-container {
            display: none; /* Versteckt den Container komplett */
        }

        /* --- Kp-Index Info Popup (integriert ins Design) --- */
        .kp-info-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.2s;
        }
        .kp-info-button:hover {
            background-color: #0056b3;
        }
        .kp-info {
            background-color: #3e3e5a;
            color: #e0e0e0;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: left;
            display: none;
            width: 100%;
            box-sizing: border-box;
        }
        .kp-info strong { color: #ff9800; }
        .kp-info ul { list-style-type: disc; margin-left: 20px; padding: 0; }
        .kp-info li { margin-bottom: 5px; }

        /* --- Image Popups --- */
        .image-placeholder {
            width: 100%;
            height: 180px;
            background-color: #1e1e32;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #b0b0b0;
            font-size: 0.9em;
            cursor: pointer;
            overflow: hidden;
            background-size: contain; /* Changed to contain for D-Region, better for some dynamic images */
            background-repeat: no-repeat;
            background-position: center;
            margin-top: 15px;
            position: relative;
        }
        .image-placeholder img, .image-placeholder iframe {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .image-popup {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); display: none;
            justify-content: center; align-items: center; z-index: 1002; cursor: pointer;
        }
        .image-popup img, .image-popup iframe { max-width: 90%; max-height: 90%; object-fit: contain; }
    </style>
</head>
<body>

<h1><i class="fas fa-satellite"></i> SpaceWeatherNow Dashboard</h1>

<div class="dashboard">
    <div class="card" data-chart-type="Kp">
        <i class="fas fa-bolt icon"></i>
        <h2>Kp-Index</h2>
        <div class="value-container">
            <span id="kp-index" class="value loading">Lade...</span>
            <span class="unit"></span>
        </div>
        <p class="description">Der Kp-Index misst die globale geomagnetische Aktivität. Höhere Werte bedeuten stärkere geomagnetische Stürme und eine höhere Wahrscheinlichkeit für Polarlichter.</p>
        <canvas id="chartKpSmall"></canvas>
        <button class="kp-info-button" onclick="toggleKpInfo(event)">Mehr Infos zum Kp-Index</button>
        <div id="kp-info" class="kp-info">
            <strong>Kp-Werte und ihre Bedeutung (ungefähr):</strong>
            <ul>
                <li>Kp 0-4: Geringe Aktivität (Polarlichter meist nur in hohen Breiten)</li>
                <li>Kp 5-6: Mäßige Aktivität (Polarlichter eventuell in mittleren Breiten sichtbar)</li>
                <li>Kp 7-8: Starke Aktivität (Gute Chancen für Polarlichter, eventuell in niedrigen breiten)</li>
                <li>Kp 9: Extreme Aktivität (Sehr hohe Wahrscheinlichkeit für Polarlichter, weltweit sichtbar unter optimalen Bedingungen!)</li>
            </ul>
        </div>
    </div>

    <div class="card" data-chart-type="IMFz">
        <i class="fas fa-magnet icon"></i>
        <h2>Bz-Wert</h2>
        <div class="value-container">
            <span id="bz-value" class="value loading">Lade...</span>
            <span class="unit">nT</span>
        </div>
        <p class="description">Die **Nord-Süd-Komponente** des Interplanetaren Magnetfelds (IMF). Ein negativer Bz-Wert (nach Süden gerichtet) ist entscheidend für das Eintreten von Polarlichtern.</p>
        <canvas id="chartBzSmall"></canvas>
    </div>

    <div class="card" data-chart-type="Speed">
        <i class="fas fa-wind icon"></i>
        <h2>Solarwind - Geschwindigkeit</h2>
        <div class="value-container">
            <span id="solar-wind-speed" class="value loading">Lade...</span>
            <span class="unit">km/s</span>
        </div>
        <p class="description">Die Geschwindigkeit, mit der der Sonnenwind auf das Erdmagnetfeld trifft. Höhere Geschwindigkeiten können die Polarlichtintensität erhöhen.</p>
        <canvas id="chartSpeedSmall"></canvas>
    </div>

    <div class="card" data-chart-type="Density">
        <i class="fas fa-atom icon"></i>
        <h2>Solarwinddichte</h2>
        <div class="value-container">
            <span id="solar-wind-density" class="value loading">Lade...</span>
            <span class="unit">p/cm³</span>
        </div>
        <p class="description">Die Anzahl der Teilchen im Sonnenwind. Eine höhere Dichte liefert mehr Material für die Wechselwirkung mit dem Erdmagnetfeld.</p>
        <canvas id="chartDensitySmall"></canvas>
    </div>

    <div class="card" data-chart-type="IMF">
        <i class="fas fa-solar-panel icon"></i>
        <h2>Bt-Wert (IMF Total)</h2>
        <div class="value-container">
            <span id="bt-value" class="value loading">Lade...</span>
            <span class="unit">nT</span>
        </div>
        <p class="description">Die **Gesamtstärke** des Interplanetaren Magnetfelds (IMF). Ein starkes IMF, besonders bei negativem Bz, kann zu intensiveren Polarlichtern führen.</p>
        <canvas id="chartBtSmall"></canvas>
    </div>

    <div class="card" data-chart-type="DST">
        <i class="fas fa-chart-line icon"></i>
        <h2>DST-Index</h2>
        <div class="value-container">
            <span id="dst-index" class="value loading">Lade...</span>
            <span class="unit">nT</span>
        </div>
        <p class="description">Der Disturbance Storm Time (DST) Index misst die Stärke des äquatorialen Ringstroms. Starke negative Werte deuten auf geomagnetische Stürme hin.</p>
        <canvas id="chartDstSmall"></canvas>
    </div>

    <div class="card">
        <i class="fas fa-chart-area icon"></i>
        <h2>ACE Mag & SWEPAM</h2>
        <div id="ace-mag-swepam-placeholder" class="image-placeholder"
             onclick="showImagePopup('https://services.swpc.noaa.gov/images/ace-mag-swepam-24-hour.gif')"
             style="background-image: url('https://services.swpc.noaa.gov/images/ace-mag-swepam-24-hour.gif');">
        </div>
        <p class="description">Magnetfeld- und Sonnenwinddaten vom ACE-Satelliten der letzten 24 Stunden.</p>
        <p class="utc-notice">Bitte beachten Sie: Die Zeitangaben in diesen Grafiken sind in UTC. Addieren Sie 2 Stunden für die lokale Zeit (MESZ/MEZ).</p>
    </div>

    <div class="card">
        <i class="fas fa-chart-pie icon"></i>
        <h2>ACE EPAM</h2>
        <div id="ace-epam-placeholder" class="image-placeholder"
             onclick="showImagePopup('https://services.swpc.noaa.gov/images/ace-epam-3-day.gif')"
             style="background-image: url('https://services.swpc.noaa.gov/images/ace-epam-3-day.gif');">
        </div>
        <p class="description">Elektronen- und Protonenaktivität vom ACE-Satelliten der letzten 3 Tage.</p>
        <p class="utc-notice">Bitte beachten Sie: Die Zeitangaben in diesen Grafiken sind in UTC. Addieren Sie 2 Stunden für die lokale Zeit (MESZ/MEZ).</p>
    </div>

    <div class="card">
        <i class="fas fa-wifi icon"></i>
        <h2>D-Region Absorption</h2>
        <div id="dynamicImage2Container" class="image-placeholder"
             onclick="if (document.getElementById('dynamicImage2').src) { showImagePopup(document.getElementById('dynamicImage2').src); }">
            <img id="dynamicImage2" src="" alt="D-Region Absorption" style="display: none;"> <span id="dRegionLoading" style="color: #b0b0b0;">Lade Bild...</span>
        </div>
        <p class="description">Zeigt die Radioabsorptionszone in der D-Region der Ionosphäre, beeinflusst durch Sonnenstrahlung.</p>
        <p class="utc-notice">Bitte beachten Sie: Die Zeitangaben in diesen Grafiken sind in UTC. Addieren Sie 2 Stunden für die lokale Zeit (MESZ/MEZ).</p>
    </div>

    <div class="card">
        <i class="fas fa-cloud-sun-rain icon"></i>
        <h2>Aurora Vorhersage (Nord)</h2>
        <div class="image-placeholder"
             onclick="showImagePopup('https://services.swpc.noaa.gov/images/animations/ovation/north/latest.jpg')"
             style="background-image: url('https://services.swpc.noaa.gov/images/animations/ovation/north/latest.jpg');">
        </div>
        <p class="description">Aktuelle Vorhersage der Polarlichtverteilung über der Nordhalbkugel.</p>
    </div>

    <div class="card">
        <i class="fas fa-location-dot icon"></i>
        <h2>Dein Standort</h2>
        <div class="value-container">
            <span id="latitude" class="value loading">Lade...</span>
            <span class="unit">Breitengrad</span>
        </div>
        <div class="value-container">
            <span id="longitude" class="value loading">Lade...</span>
            <span class="unit">Längengrad</span>
        </div>
        <p class="description">Deine geografischen Koordinaten, die zur Berechnung der Polarlichtwahrscheinlichkeit genutzt werden.</p>
    </div>

    <div class="card">
        <i class="fas fa-sparkles icon"></i>
        <h2>Polarlicht-Wahrscheinlichkeit</h2>
        <div class="value-container">
            <span id="aurora-probability" class="value loading">Lade...</span>
            <span class="unit"></span>
        </div>
        <p class="description">Eine Schätzung der Polarlichtwahrscheinlichkeit basierend auf deinen Koordinaten und aktuellen Weltraumwetterdaten. Beachte: Dies ist nur eine vereinfachte Vorhersage!</p>
    </div>

</div>

<div id="chartModal" class="modal">
    <div class="modal-content">
        <span class="close-button">×</span>
        <h2 id="modalChartTitle"></h2>
        <div class="modal-chart-container">
            <canvas id="modalChart"></canvas>
        </div>
        <div class="time-selector-container">
            </div>
    </div>
</div>

<div id="image-popup" class="image-popup" onclick="hideImagePopup()">
    <img id="popup-image" src="" alt="Großansicht">
    <iframe id="popup-iframe" src="" frameborder="0" allowfullscreen style="display:none;"></iframe>
</div>

<script>
    // Konfigurieren des Luxon Adapters für Chart.js
    // Wichtig: Setze die globale Zeitzone für Luxon, die Chart.js verwenden soll
    // Europa/Berlin berücksichtigt Sommer- und Winterzeit korrekt
    Chart.defaults.plugins.tooltip.position = 'nearest'; // Standardposition für Tooltips
    Chart.defaults.parsing.dateTimeData = {
        parser: function(value) {
            // Parse UTC ISO string, then set to Europe/Berlin for display
            return luxon.DateTime.fromISO(value, { zone: 'utc' }).setZone('Europe/Berlin');
        }
    };
    // Standardeinstellungen für die Zeitachse in allen Charts
    Chart.defaults.scale.time = {
        tooltipFormat: 'dd.MM.yyyy HH:mm:ss', // Anzeigeformat im Tooltip
        displayFormats: {
            minute: 'HH:mm',
            hour: 'HH:mm',
            day: 'dd.MM'
        }
    };


    // --- Globale Variablen für Weltraumwetterdaten ---
    let currentKpIndex = 0;
    let currentBz = 0;
    let currentSolarWindSpeed = 0;
    let currentSolarWindDensity = 0;
    let currentBt = 0;

    // --- Variablen für historische Chart.js Daten (werden durch API-Aufrufe befüllt) ---
    // Diese Arrays werden Objekte vom Typ { x: ISO-String (UTC), y: Wert } enthalten
    let historicalDataKp = [];
    let historicalDataIMFz = [];
    let historicalDataSpeed = [];
    let historicalDataDensity = [];
    let historicalDataIMF = [];
    let historicalDataDst = [];
    // let historicalDataXray = []; // Entfernt
    // let historicalDataRadioFlux = []; // Entfernt

    let smallChartInstances = {}; // Zum Speichern von Instanzen kleiner Charts
    let currentModalChartType = null;
    let modalChartInstance = null;

    // --- Hilfsfunktion zur Umwandlung von Röntgenklasse in einen numerischen Wert ---
    /* Entfernt, da X-Ray Flux entfernt wurde
    function convertXrayClassToNumber(xrayClass) {
        if (!xrayClass) return 0;
        const letter = xrayClass.charAt(0);
        const number = parseFloat(xrayClass.substring(1));
        let baseValue = 0;
        if (letter === 'A') baseValue = 1e-8;
        else if (letter === 'B') baseValue = 1e-7;
        else if (letter === 'C') baseValue = 1e-6;
        else if (letter === 'M') baseValue = 1e-5;
        else if (letter === 'X') baseValue = 1e-4;
        return number * baseValue;
    }
    */

    // --- Hilfsfunktion zur Umwandlung des numerischen Werts zurück in die Röntgenklasse ---
    /* Entfernt, da X-Ray Flux entfernt wurde
    function convertNumberToXrayClass(numValue) {
        if (numValue === 0) return 'A0.0';
        let letter = '';
        let number = 0;

        if (numValue >= 1e-4) { letter = 'X'; number = numValue / 1e-4; }
        else if (numValue >= 1e-5) { letter = 'M'; number = numValue / 1e-5; }
        else if (numValue >= 1e-6) { letter = 'C'; number = numValue / 1e-6; }
        else if (numValue >= 1e-7) { letter = 'B'; number = numValue / 1e-7; }
        else if (numValue >= 1e-8) { letter = 'A'; number = numValue / 1e-8; }
        else { return 'A0.0'; }

        return ``; // Zeigt eine Nachkommastelle
    }
    */

    // --- Hilfsfunktion zum Slicen der Daten für einen bestimmten Zeitraum (UTC+2 basierend) ---
    // Erwartet sourceData als Array von {x: ISO-String (UTC), y: value}
    function getSlicedData(sourceData, hours) {
        if (!sourceData || sourceData.length === 0) return [];

        // Bestimme die aktuelle Zeit in der gewünschten Anzeigezeitzone (Europe/Berlin)
        const nowInBerlin = luxon.DateTime.now().setZone('Europe/Berlin');
        // Berechne die Startzeit, indem 'hours' von der aktuellen Zeit in Berlin abgezogen wird
        const startTimeInBerlin = nowInBerlin.minus({ hours: hours });

        // Konvertiere diese Berliner Startzeit zurück nach UTC, um die Quelldaten zu filtern
        const startTimeUTC = startTimeInBerlin.toUTC();

        const filteredData = sourceData.filter(dp => {
            const dpTimeUTC = luxon.DateTime.fromISO(dp.x, { zone: 'utc' });
            return dpTimeUTC >= startTimeUTC;
        });

        // Stelle sicher, dass die Daten für Chart.js nach der Zeit sortiert sind
        return filteredData.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());
    }


    // --- Funktion zum Abrufen historischer Daten für Charts ---
    async function fetchHistoricalSpaceWeatherData() {
        try {
            const [responseMag, responseWind, responseKpHistorical, responseDstHistorical] = await Promise.all([
                fetch('https://services.swpc.noaa.gov/json/dscovr/dscovr_mag_1s.json'),
                fetch('https://services.swpc.noaa.gov/json/rtsw/rtsw_wind_1m.json'),
                fetch('https://services.swpc.noaa.gov/json/planetary_k_index_1m.json'),
                fetch('https://services.swpc.noaa.gov/json/geospace/geospace_dst_1_hour.json')
            ]);

            const dataMag = await responseMag.json();
            const dataWind = await responseWind.json();
            const dataKpHistorical = await responseKpHistorical.json();
            const dataDstHistorical = await responseDstHistorical.json();

            // Vorherige historische Daten löschen
            historicalDataKp = [];
            historicalDataIMFz = [];
            historicalDataSpeed = [];
            historicalDataDensity = [];
            historicalDataIMF = [];
            historicalDataDst = [];

            // Kp-Daten verarbeiten
            dataKpHistorical.forEach(item => {
                // Time_tag ist bereits im ISO-Format (UTC), so speichern
                if (item.kp_index !== null) {
                    historicalDataKp.push({ x: item.time_tag, y: parseFloat(item.kp_index) });
                }
            });
            historicalDataKp.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());


            // Magnetometerdaten (Bz und Bt) verarbeiten
            // Um die Daten von den neuesten links nach den ältesten rechts zu sortieren, kehren wir die Reihenfolge um
            dataMag.forEach(item => {
                if (item.bz_gsm !== null) historicalDataIMFz.push({ x: item.time_tag, y: parseFloat(item.bz_gsm) });
                if (item.bt !== null) historicalDataIMF.push({ x: item.time_tag, y: parseFloat(item.bt) });
            });
            historicalDataIMFz.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());
            historicalDataIMF.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());


            // Winddaten (Geschwindigkeit und Dichte) verarbeiten
            dataWind.filter(item => item.source === 'DSCOVR').forEach(item => {
                if (item.proton_speed !== null) historicalDataSpeed.push({ x: item.time_tag, y: parseFloat(item.proton_speed) });
                if (item.proton_density !== null) historicalDataDensity.push({ x: item.time_tag, y: parseFloat(item.proton_density) });
            });
            historicalDataSpeed.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());
            historicalDataDensity.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());

            // DST-Daten verarbeiten
            dataDstHistorical.forEach(item => {
                if (item.dst !== null) {
                    historicalDataDst.push({ x: item.time_tag, y: parseFloat(item.dst) });
                }
            });
            historicalDataDst.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());


            renderSmallCharts();

        } catch (error) {
            console.error('Fehler beim Abrufen historischer Daten:', error);
        }
    }

    // --- Kleine Chart-Rendering-Funktion ---
    function renderSmallCharts() {
        for (const chartId in smallChartInstances) {
            if (smallChartInstances[chartId]) smallChartInstances[chartId].destroy();
        }
        smallChartInstances = {};

        // Optionen für alle kleinen Charts (immer für die letzten 3 Stunden)
        const commonChartOptions = (specificTimeUnit = 'hour') => ({
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
                x: {
                    type: 'time',
                    time: {
                        unit: specificTimeUnit,
                        tooltipFormat: 'dd.MM.yyyy HH:mm:ss', // Consistent full tooltip format
                        displayFormats: {
                            minute: 'HH:mm',
                            hour: 'HH:mm',
                            day: 'dd.MM'
                        }
                    },
                    adapters: {
                        date: {
                            zone: 'Europe/Berlin' // Force timezone for the X-axis
                        }
                    },
                    ticks: { color: '#888', maxRotation: 0, autoSkipPadding: 10, source: 'auto', maxTicksLimit: 6 },
                    grid: { color: 'rgba(255,255,255,0.05)' }
                },
                y: {
                    ticks: { color: '#888' },
                    grid: { color: 'rgba(255,255,255,0.05)' }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            if (context[0] && context[0].parsed && context[0].parsed.x) {
                                // The x value is already in milliseconds, Luxon can convert it to Europe/Berlin
                                return luxon.DateTime.fromMillis(context[0].parsed.x, { zone: 'Europe/Berlin' }).toLocaleString(luxon.DateTime.DATETIME_SHORT_WITH_SECONDS);
                            }
                            return '';
                        },
                        label: function(context) {
                            let lbl = context.dataset.label || '';
                            if (lbl) lbl += ': ';
                            if (context.parsed.y !== null) {
                                // if (context.dataset.label === 'X-Ray-Flux') { // Specific check for Xray - Entfernt
                                //     lbl += convertNumberToXrayClass(context.parsed.y);
                                // } else {
                                    lbl += context.parsed.y.toFixed(2);
                                    if (context.dataset.label === 'Bz-Wert' || context.dataset.label === 'IMF total field' || context.dataset.label === 'DST-Index') lbl += ' nT';
                                    else if (context.dataset.label === 'Geschwindigkeit') lbl += ' km/s';
                                    else if (context.dataset.label === 'Dichte') lbl += ' p/cm³';
                                    // else if (context.dataset.label === 'Radio Flux') lbl += ' sfu'; // Entfernt
                                // }
                            }
                            return lbl;
                        }
                    }
                }
            }
        });

        const chartConfigs = {
            'chartKpSmall': { label: 'Kp-Index', data: getSlicedData(historicalDataKp, 3), color: '#00bcd4', timeUnit: 'minute' },
            'chartBzSmall': { label: 'Bz-Wert', data: getSlicedData(historicalDataIMFz, 3), color: '#ff9800', timeUnit: 'minute' },
            'chartSpeedSmall': { label: 'Geschwindigkeit', data: getSlicedData(historicalDataSpeed, 3), color: '#4caf50', timeUnit: 'minute' },
            'chartDensitySmall': { label: 'Dichte', data: getSlicedData(historicalDataDensity, 3), color: '#e57373', timeUnit: 'minute' },
            'chartBtSmall': { label: 'Bt-Wert', data: getSlicedData(historicalDataIMF, 3), color: '#2196f3', timeUnit: 'minute' },
            'chartDstSmall': { label: 'DST-Index', data: getSlicedData(historicalDataDst, 3), color: '#f44336', timeUnit: 'minute' },
            // 'chartXraySmall': { label: 'X-Ray-Flux', data: getSlicedData(historicalDataXray, 3), color: '#ffeb3b', timeUnit: 'minute' }, // Entfernt
            // 'chartRadioFluxSmall': { label: 'Radio Flux', data: historicalDataRadioFlux, color: '#9c27b0', isSinglePoint: true }, // Entfernt
        };

        for (const id in chartConfigs) {
            const ctx = document.getElementById(id);
            if (ctx) {
                const config = chartConfigs[id];
                const chartData = {
                    datasets: [{
                        label: config.label,
                        data: config.data,
                        borderColor: config.color,
                        backgroundColor: 'transparent',
                        tension: 0.3,
                        pointRadius: 0
                    }]
                };
                let options = commonChartOptions(config.timeUnit || 'hour');

                /* Entfernt, da X-Ray Flux entfernt wurde
                // Special handling for Xray small chart y-axis
                if (id === 'chartXraySmall') {
                    options.scales.y = {
                        type: 'logarithmic',
                        ticks: {
                            callback: function(value, index, values) {
                                return convertNumberToXrayClass(value);
                            },
                            color: '#888'
                        },
                        grid: { color: 'rgba(255,255,255,0.05)' }
                    };
                }
                */

                if (config.isSinglePoint) { // Dies wird für RadioFlux nicht mehr benötigt, aber falls andere SinglePoint-Daten hinzugefügt werden
                    options.scales.x = {
                        type: 'category', // For single point, category axis is better
                        labels: config.data.map(dp => luxon.DateTime.fromISO(dp.x, { zone: 'utc' }).setZone('Europe/Berlin').toFormat('HH:mm')),
                        ticks: { color: '#888'},
                        grid: {display: false}
                    };
                    chartData.datasets[0].pointRadius = 3;
                }

                smallChartInstances[id] = new Chart(ctx, { type: 'line', data: chartData, options: options });
            }
        }
    }

    // --- Abrufen und Aktualisieren der aktuellen Echtzeitdaten ---
    async function fetchSpaceWeatherData() {
        try {
            const [
                resKp, resWind, resMag, resDst /* , resXrayCurrent, resRadioFlux, resXray7Day */ // Entfernt
            ] = await Promise.all([
                fetch('https://services.swpc.noaa.gov/json/planetary_k_index_1m.json'),
                fetch('https://services.swpc.noaa.gov/json/rtsw/rtsw_wind_1m.json'),
                fetch('https://services.swpc.noaa.gov/json/dscovr/dscovr_mag_1s.json'),
                fetch('https://services.swpc.noaa.gov/json/geospace/geospace_dst_1_hour.json'),
                // fetch("https://services.swpc.noaa.gov/json/goes/primary/xray-flares-latest.json"), // Entfernt
                // fetch("https://services.swpc.noaa.gov/products/summary/10cm-flux.json"), // Entfernt
                // fetch("https://services.swpc.noaa.gov/json/goes/primary/xray-flares-7-day.json") // Entfernt
            ]);

            const dataKp = await resKp.json();
            const dataWind = await resWind.json();
            const dataMag = await resMag.json();
            const dataDst = await resDst.json();
            // const dataXrayCurrent = await resXrayCurrent.json(); // Entfernt
            // const dataRadioFlux = await resRadioFlux.json(); // Entfernt
            // const dataXray7Day = await resXray7Day.json(); // Entfernt

            // Kp Index - Neueste ist oft am Ende des Arrays
            const latestKpData = dataKp[dataKp.length - 1];
            currentKpIndex = latestKpData && latestKpData.kp_index !== null ? parseFloat(latestKpData.kp_index) : 0;
            document.getElementById('kp-index').textContent = latestKpData ? currentKpIndex.toFixed(1) : 'N/A';

            // Solar Wind Speed & Density
            const latestWindData = dataWind.filter(item => item.source === 'DSCOVR' && item.proton_speed !== null && item.proton_density !== null)
                                            .sort((a,b) => luxon.DateTime.fromISO(b.time_tag, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(a.time_tag, { zone: 'utc' }).toMillis())[0];
            currentSolarWindSpeed = latestWindData ? parseFloat(latestWindData.proton_speed) : 0;
            currentSolarWindDensity = latestWindData ? parseFloat(latestWindData.proton_density) : 0;
            document.getElementById('solar-wind-speed').textContent = latestWindData ? currentSolarWindSpeed.toFixed(0) : 'N/A';
            document.getElementById('solar-wind-density').textContent = latestWindData ? currentSolarWindDensity.toFixed(2) : 'N/A';

            // Bz & Bt from 1s DSCOVR mag data (most recent is usually at index 0)
            const latestMagData = dataMag[0];
            currentBz = latestMagData && latestMagData.bz_gsm !== null ? parseFloat(latestMagData.bz_gsm) : 0;
            currentBt = latestMagData && latestMagData.bt !== null ? parseFloat(latestMagData.bt) : 0;
            document.getElementById('bz-value').textContent = latestMagData ? currentBz.toFixed(2) : 'N/A';
            document.getElementById('bt-value').textContent = latestMagData ? currentBt.toFixed(2) : 'N/A';

            // DST Index (most recent is usually at index 0)
            const latestDstData = dataDst[0];
            document.getElementById('dst-index').textContent = latestDstData && latestDstData.dst !== null ? parseFloat(latestDstData.dst).toFixed(2) : 'N/A';

            /* Entfernt, da X-Ray Flux entfernt wurde
            // X-Ray Flux Current (latest.json returns a single object in an array)
            const latestXrayCurrentData = dataXrayCurrent[0];
            document.getElementById('solar-activity').textContent = latestXrayCurrentData ? latestXrayCurrentData.current_class : 'N/A';

            // Max X-Ray Flux 24h
            const nowInBerlin = luxon.DateTime.now().setZone('Europe/Berlin');
            const dayAgoUTC = nowInBerlin.minus({ hours: 24 }).toUTC();
            let maxClassValueNumeric = 0;
            let maxClassString = 'A0.0';

            dataXray7Day.forEach(item => {
                // Compare item's UTC time_tag with our UTC threshold
                if (item.time_tag && luxon.DateTime.fromISO(item.time_tag, { zone: 'utc' }) >= dayAgoUTC) {
                    const classValue = item.max_class || item.xray_class;
                    if (classValue) {
                        const numericValue = convertXrayClassToNumber(classValue);
                        if (numericValue > maxClassValueNumeric) {
                            maxClassValueNumeric = numericValue;
                            maxClassString = classValue;
                        }
                    }
                }
            });
            document.getElementById('solar-activity-max').textContent = maxClassString;

            // Radio Flux 10.7cm
            document.getElementById('radio-flux').textContent = dataRadioFlux && dataRadioFlux.Flux ? parseFloat(dataRadioFlux.Flux).toFixed(2) : 'N/A';
            */

            // Alle "Lade..."-Texte entfernen und ggf. Fehlertexte zurücksetzen
            document.querySelectorAll('.value.loading').forEach(element => {
                element.classList.remove('loading');
            });
            document.querySelectorAll('.value-container .error').forEach(element => {
                element.classList.remove('error');
            });

        } catch (error) {
            console.error('Fehler beim Abrufen der aktuellen Daten:', error);
            // Alle "Lade..."-Texte in "Fehler!" ändern
            document.querySelectorAll('.value').forEach(element => {
                if (element.classList.contains('loading')) { // Nur aktualisieren, wenn noch geladen wird
                    element.textContent = 'Fehler!';
                    element.classList.remove('loading');
                    element.classList.add('error');
                }
            });
        }
    }

    // --- Geolocation und Polarlichtwahrscheinlichkeit ---
    async function getLocationAndCalculateAuroraProbability() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(async position => {
                const latitude = position.coords.latitude;
                const longitude = position.coords.longitude;

                document.getElementById('latitude').textContent = latitude.toFixed(2);
                document.getElementById('longitude').textContent = longitude.toFixed(2);

                updateAuroraProbability(latitude);
                document.getElementById('latitude').classList.remove('loading');
                document.getElementById('longitude').classList.remove('loading');
                document.getElementById('aurora-probability').classList.remove('loading');
            }, error => {
                console.error("Fehler bei der Standortbestimmung:", error);
                document.getElementById('latitude').textContent = 'Nicht verfügbar';
                document.getElementById('longitude').textContent = 'Nicht verfügbar';
                document.getElementById('aurora-probability').textContent = 'Nicht verfügbar';
                ['latitude', 'longitude', 'aurora-probability'].forEach(id => {
                    document.getElementById(id).classList.remove('loading');
                    document.getElementById(id).classList.add('error');
                });
            });
        } else {
            console.error("Geolocation wird von diesem Browser nicht unterstützt.");
            ['latitude', 'longitude', 'aurora-probability'].forEach(id => {
                document.getElementById(id).textContent = 'Nicht unterstützt';
                document.getElementById(id).classList.remove('loading');
                document.getElementById(id).classList.add('error');
            });
        }
    }

    function updateAuroraProbability(latitude) {
        if (latitude === undefined || currentKpIndex === undefined || currentBz === undefined || currentSolarWindSpeed === undefined || currentSolarWindDensity === undefined || currentBt === undefined) {
            document.getElementById('aurora-probability').textContent = 'Daten fehlen';
            document.getElementById('aurora-probability').classList.add('error');
            return;
        }

        let probability = 0;

        if (latitude > 70) probability += 20;
        else if (latitude > 65) probability += 10;
        else if (latitude > 60) probability += 5;
        else probability -= 15;
        probability = Math.max(0, probability);

        if (currentKpIndex >= 5) probability += (currentKpIndex - 4) * 10;
        else if (currentKpIndex >= 3) probability += (currentKpIndex - 2) * 3;

        if (currentBz < -15) probability += 20;
        else if (currentBz < -10) probability += 10;
        else if (currentBz < -5) probability += 5;

        if (currentSolarWindSpeed > 700) probability += 10;
        else if (currentSolarWindSpeed > 600) probability += 5;
        else if (currentSolarWindSpeed > 500) probability += 2;

        if (currentSolarWindDensity > 30) probability += 3;
        else if (currentSolarWindDensity > 20) probability += 1;

        if (currentBt > 20) probability += 2;
        else if (currentBt > 15) probability += 1;

        probability = Math.max(0, Math.min(100, probability));
        document.getElementById('aurora-probability').textContent = probability.toFixed(0) + '%';
        document.getElementById('aurora-probability').classList.remove('loading', 'error');
    }

    // --- Dynamische Bildaktualisierungen (D-Region) ---
    function updateDRegionImage() {
        const jsonUrl = 'https://services.swpc.noaa.gov/products/animations/d-rap_global.json';
        const baseUrl = 'https://services.swpc.noaa.gov';
        const imgElement = document.getElementById('dynamicImage2');
        const placeholderDiv = document.getElementById('dynamicImage2Container');
        const loadingSpan = document.getElementById('dRegionLoading');

        imgElement.style.display = 'none'; // Hide image while loading
        loadingSpan.style.display = 'block'; // Show loading text

        fetch(jsonUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: `);
                }
                return response.json();
            })
            .then(data => {
                let imageUrl;
                // Find the latest image URL from the array
                if (Array.isArray(data) && data.length > 0) {
                    imageUrl = baseUrl + data[data.length - 1].url;
                    imgElement.onload = () => {
                        imgElement.style.display = 'block';
                        loadingSpan.style.display = 'none';
                    };
                    imgElement.onerror = () => {
                        imgElement.style.display = 'none';
                        loadingSpan.textContent = 'Bild Ladefehler';
                    };
                    imgElement.src = imageUrl;
                } else {
                    console.error("JSON-Struktur für D-Region Bild nicht erkannt oder leer.");
                    imgElement.style.display = 'none';
                    loadingSpan.textContent = 'Bild nicht verfügbar';
                }
            })
            .catch(error => {
                console.error("Fehler beim Abrufen der JSON-Datei für D-Region Bild:", error);
                imgElement.style.display = 'none';
                loadingSpan.textContent = 'Bild Ladefehler';
            });
    }

    // --- Kp-Info Umschalter ---
    function toggleKpInfo(event) {
        event.stopPropagation();
        const kpInfoDiv = document.getElementById('kp-info');
        kpInfoDiv.style.display = (kpInfoDiv.style.display === 'none' || kpInfoDiv.style.display === '') ? 'block' : 'none';
    }

    // --- Bild-Popup für Großansichten ---
    function showImagePopup(mediaUrl) {
        const popup = document.getElementById('image-popup');
        const popupImage = document.getElementById('popup-image');
        const popupIframe = document.getElementById('popup-iframe');

        popupImage.style.display = 'none';
        popupIframe.style.display = 'none';

        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif'];
        const isImage = imageExtensions.some(ext => mediaUrl.toLowerCase().endsWith(ext));

        if (isImage) {
            popupImage.src = mediaUrl;
            popupImage.alt = "Großansicht";
            popupImage.style.display = 'block';
        } else {
            popupIframe.src = mediaUrl;
            popupIframe.style.display = 'block';
        }
        popup.style.display = 'flex';
    }

    function hideImagePopup() {
        const popup = document.getElementById('image-popup');
        popup.style.display = 'none';
        document.getElementById('popup-image').src = '';
        document.getElementById('popup-iframe').src = '';
    }

    // --- X-Flare Alarm ---
    /* Entfernt, da X-Ray Flux entfernt wurde
    async function checkSolarActivityForXFlare() {
        try {
            const response = await fetch("https://services.swpc.noaa.gov/json/goes/primary/xray-flares-7-day.json");
            const data = await response.json();
            const nowInBerlin = luxon.DateTime.now().setZone('Europe/Berlin');
            const lastHourUTC = nowInBerlin.minus({ hours: 1 }).toUTC(); // Compare with UTC time from data

            const newXFlareDetected = data.some(item =>
                item.time_tag && luxon.DateTime.fromISO(item.time_tag, { zone: 'utc' }) > lastHourUTC && item.max_class && item.max_class.startsWith('X')
            );

            if (newXFlareDetected && !sessionStorage.getItem('xFlareAlerted')) {
                alert("Achtung! Eine starke X-Sonneneruption wurde registriert!");
                sessionStorage.setItem('xFlareAlerted', 'true');
            }
        } catch (error) {
            console.error("Fehler beim Abrufen der X-Flare-Daten für Alert:", error);
        }
    }
    */

    // --- Modal Chart Funktionalität ---
    const chartModal = document.getElementById('chartModal');
    const closeButton = chartModal.querySelector('.close-button');
    const modalChartCanvas = document.getElementById('modalChart');
    const modalChartTitle = document.getElementById('modalChartTitle');
    // Removed reference to timeSelectorContainer as it's now hidden

    document.querySelectorAll('.card[data-chart-type]').forEach(card => {
        card.addEventListener('click', function(event) {
            // Prevent modal from opening if info button was clicked
            if (event.target.classList.contains('kp-info-button')) {
                return;
            }
            currentModalChartType = this.dataset.chartType;
            const title = this.querySelector('h2').textContent;
            modalChartTitle.textContent = title;
            chartModal.style.display = 'flex';

            // Always render for 3 hours, no specific period selection needed from buttons
            renderModalChart('3h');
        });
    });

    closeButton.addEventListener('click', function() {
        chartModal.style.display = 'none';
        if (modalChartInstance) {
            modalChartInstance.destroy();
            modalChartInstance = null;
        }
    });

    window.addEventListener('click', function(event) {
        if (event.target == chartModal) {
            chartModal.style.display = 'none';
            if (modalChartInstance) {
                modalChartInstance.destroy();
                modalChartInstance = null;
            }
        }
    });

    function renderModalChart(period) { // Period will always be '3h' now
        let chartData, chartLabel, color, valueSuffix = '', timeUnit = 'minute';
        let hours = parseInt(period.replace('h', '')); // Will always be 3

        let sourceFullData;

        switch(currentModalChartType) {
            case 'Kp':
                sourceFullData = historicalDataKp; chartLabel = 'Kp-Index'; color = '#00bcd4';
                break;
            case 'IMFz':
                sourceFullData = historicalDataIMFz; chartLabel = 'Bz-Wert'; color = '#ff9800'; valueSuffix = ' nT';
                break;
            case 'Speed':
                sourceFullData = historicalDataSpeed; chartLabel = 'Solarwindgeschwindigkeit'; color = '#4caf50'; valueSuffix = ' km/s';
                break;
            case 'Density':
                sourceFullData = historicalDataDensity; chartLabel = 'Solarwinddichte'; color = '#e57373'; valueSuffix = ' p/cm³';
                break;
            case 'IMF':
                sourceFullData = historicalDataIMF; chartLabel = 'Bt-Wert'; color = '#2196f3'; valueSuffix = ' nT';
                break;
            case 'DST':
                sourceFullData = historicalDataDst; chartLabel = 'DST-Index'; color = '#f44336'; valueSuffix = ' nT';
                break;
            /* Entfernt, da X-Ray Flux und Radio Flux entfernt wurden
            case 'Xray':
                sourceFullData = historicalDataXray; chartLabel = 'X-Ray-Flux'; color = '#ffeb3b';
                break;
            case 'RadioFlux':
                // For single point, we just use the latest data
                chartData = historicalDataRadioFlux.length > 0 ? [historicalDataRadioFlux[historicalDataRadioFlux.length - 1]] : [{x: luxon.DateTime.now().setZone('Europe/Berlin').toISO(), y:0}];
                chartLabel = 'Radio Flux 10.7cm'; color = '#9c27b0'; valueSuffix = ' sfu';
                break;
            */
            default: return;
        }

        // if (currentModalChartType !== 'RadioFlux') { // Bedingung angepasst
            chartData = getSlicedData(sourceFullData, hours); // Always slices for 3 hours
        // }

        if (modalChartInstance) {
            modalChartInstance.data.datasets[0].data = chartData;
            modalChartInstance.options.scales.x.time.unit = timeUnit;
            /* Entfernt, da X-Ray Flux entfernt wurde
            // Update Y-axis for Xray specifically
            if (currentModalChartType === 'Xray') {
                modalChartInstance.options.scales.y.type = 'logarithmic';
                modalChartInstance.options.scales.y.ticks = {
                    callback: function(value, index, values) {
                        return convertNumberToXrayClass(value);
                    },
                    color: '#b0b0b0'
                };
            } else {
                modalChartInstance.options.scales.y.type = 'linear';
                modalChartInstance.options.scales.y.ticks = { color: '#b0b0b0' };
            }
            */
            modalChartInstance.update();
        } else {
            let xAxisTicksConfig = {
                color: '#b0b0b0',
                source: 'auto',
                maxRotation: 0,
                autoSkipPadding: 15,
                major: { enabled: true }
            };

            let yAxisConfig = {
                ticks: { color: '#b0b0b0' },
                grid: { color: 'rgba(255,255,255,0.1)' }
            };

            /* Entfernt, da X-Ray Flux entfernt wurde
            if (currentModalChartType === 'Xray') {
                yAxisConfig = {
                    type: 'logarithmic',
                    ticks: {
                        callback: function(value, index, values) {
                            return convertNumberToXrayClass(value);
                        },
                        color: '#b0b0b0'
                    },
                    grid: { color: 'rgba(255,255,255,0.1)' }
                };
            }
            */

            modalChartInstance = new Chart(modalChartCanvas, {
                type: 'line',
                data: {
                    datasets: [{
                        label: chartLabel,
                        data: chartData,
                        borderColor: color,
                        backgroundColor: 'rgba(0,0,0,0)',
                        tension: 0.3,
                        // pointRadius: currentModalChartType === 'RadioFlux' ? 5 : 0 // Bedingung angepasst
                        pointRadius: 0 // Da RadioFlux entfernt wurde, immer 0
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, labels: { color: '#e0e0e0' } },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    if (context[0] && context[0].parsed && context[0].parsed.x) {
                                        // Display date/time in Europe/Berlin timezone
                                        return luxon.DateTime.fromMillis(context[0].parsed.x, { zone: 'Europe/Berlin' }).toLocaleString(luxon.DateTime.DATETIME_SHORT_WITH_SECONDS);
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    let lbl = context.dataset.label || '';
                                    if (lbl) lbl += ': ';
                                    if (context.parsed.y !== null) {
                                        // if (currentModalChartType === 'Xray') lbl += convertNumberToXrayClass(context.parsed.y); // Entfernt
                                        // else lbl += context.parsed.y.toFixed(2) + valueSuffix;
                                        lbl += context.parsed.y.toFixed(2) + valueSuffix;
                                    }
                                    return lbl;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: timeUnit,
                                tooltipFormat: 'dd.MM.yyyy HH:mm:ss',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm',
                                    day: 'dd.MM HH:mm'
                                }
                            },
                            adapters: {
                                date: {
                                    zone: 'Europe/Berlin' // Force timezone for the X-axis
                                }
                            },
                            ticks: xAxisTicksConfig,
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: yAxisConfig
                    }
                }
            });
            /* Entfernt, da RadioFlux entfernt wurde
            if (currentModalChartType === 'RadioFlux') {
                modalChartInstance.options.scales.x = {
                    type: 'category',
                    labels: chartData.map(dp => luxon.DateTime.fromISO(dp.x, { zone: 'utc' }).setZone('Europe/Berlin').toFormat('HH:mm')),
                    ticks: { color: '#b0b0b0'},
                    grid: {display: false}
                };
                modalChartInstance.update();
            }
            */
        }
    }

    // --- Initialaufrufe und Intervalle ---
    window.addEventListener('load', () => {
        getLocationAndCalculateAuroraProbability();
        fetchSpaceWeatherData();
        fetchHistoricalSpaceWeatherData();
        updateDRegionImage(); // Call once on load
        // checkSolarActivityForXFlare(); // Entfernt
    });

    setInterval(fetchSpaceWeatherData, 60000); // Every minute for current values
    setInterval(fetchHistoricalSpaceWeatherData, 5 * 60 * 1000); // Every 5 minutes for historical data/charts
    setInterval(updateDRegionImage, 60 * 1000); // Update D-Region image every minute
    // setInterval(checkSolarActivityForXFlare, 5 * 60 * 1000); // Check for X-flares every 5 minutes - Entfernt
</script>
</body>
</html>
