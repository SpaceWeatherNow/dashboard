<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaceWeatherNow Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.x/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a2e; /* Dunkler Hintergrund */
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #00bcd4; /* Akzentfarbe */
            margin-bottom: 30px;
            font-size: 2.5em;
            text-align: center;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); /* Responsives Grid */
            gap: 20px;
            max-width: 1200px; /* Maximale Breite des Dashboards */
            width: 100%;
        }

        .card {
            background-color: #2e2e4a; /* Dunklere Karte */
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
        }

        .card h2 {
            color: #00bcd4; /* Akzentfarbe für Überschriften */
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.6em;
        }

        .icon {
            font-size: 3em;
            color: #ff9800; /* Orangener Akzent für Icons */
            margin-bottom: 15px;
        }

        .value {
            font-size: 2.8em;
            font-weight: bold;
            color: #4caf50; /* Grün für Werte */
            margin-bottom: 10px;
        }

        .unit {
            font-size: 1.1em;
            color: #a0a0a0;
        }

        .description {
            font-size: 0.9em;
            color: #b0b0b0;
            margin-top: 15px;
            line-height: 1.5;
        }
        /* The .utc-notice style can remain, but the elements using it will be removed/moved */
        .utc-notice {
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
            text-align: center; /* Ensure it's centered in the modal */
        }


        .loading {
            color: #888;
            font-style: italic;
        }

        .error {
            color: #e57373;
            font-weight: bold;
        }

        canvas {
            background-color: #1e1e32;
            border-radius: 8px;
            margin-top: 15px;
            width: 100% !important; /* Wichtig für Chart.js in Flexbox */
            height: 200px; /* Feste Höhe für kleine Charts */
        }

        /* --- Modal für große Charts --- */
        .modal {
            display: none; /* Versteckt als Standard */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7); /* Dunkler, halbtransparenter Hintergrund */
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #2e2e4a;
            margin: auto;
            padding: 20px;
            border: 1px solid #4a4a6e;
            border-radius: 12px;
            width: 80%;
            max-width: 900px;
            position: relative;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {opacity: 0;}
            to {opacity: 1;}
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: #fff;
            text-decoration: none;
            cursor: pointer;
        }

        .modal-chart-container {
            width: 100%;
            height: 400px; /* Höhe für das große Chart */
            margin-top: 20px;
        }

        /* Time selector container is now empty */
        .time-selector-container {
            display: none; /* Versteckt den Container komplett */
        }

        /* --- Kp-Index Info Popup (integriert ins Design) --- */
        .kp-info-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.2s;
        }
        .kp-info-button:hover {
            background-color: #0056b3;
        }
        .kp-info {
            background-color: #3e3e5a;
            color: #e0e0e0;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: left;
            display: none;
            width: 100%;
            box-sizing: border-box;
        }
        .kp-info strong { color: #ff9800; }
        .kp-info ul { list-style-type: disc; margin-left: 20px; padding: 0; }
        .kp-info li { margin-bottom: 5px; }

        /* --- Image Popups --- */
        .image-placeholder {
            width: 100%;
            height: 180px;
            background-color: #1e1e32;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #b0b0b0;
            font-size: 0.9em;
            cursor: pointer;
            overflow: hidden;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin-top: 15px;
            position: relative;
        }
        .image-placeholder img, .image-placeholder iframe {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .image-popup {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); display: none;
            justify-content: center; align-items: center; z-index: 1002; cursor: pointer;
        }
        .image-popup img, .image-popup iframe { max-width: 90%; max-height: 90%; object-fit: contain; }
    </style>
</head>
<body>

<h1><i class="fas fa-satellite"></i> SpaceWeatherNow Dashboard</h1>

<div class="dashboard">
    <div class="card" data-chart-type="Kp">
        <i class="fas fa-bolt icon"></i>
        <h2>Kp-Index</h2>
        <div class="value-container">
            <span id="kp-index" class="value loading">Lade...</span>
            <span class="unit"></span>
        </div>
        <p class="description">Der Kp-Index misst die globale geomagnetische Aktivität. Höhere Werte bedeuten stärkere geomagnetische Stürme und eine höhere Wahrscheinlichkeit für Polarlichter.</p>
        <canvas id="chartKpSmall"></canvas>
        <button class="kp-info-button" onclick="toggleKpInfo(event)">Mehr Infos zum Kp-Index</button>
        <div id="kp-info" class="kp-info">
            <strong>Kp-Werte und ihre Bedeutung (ungefähr):</strong>
            <ul>
                <li>Kp 0-4: Geringe Aktivität (Polarlichter meist nur in hohen Breiten)</li>
                <li>Kp 5-6: Mäßige Aktivität (Polarlichter eventuell in mittleren Breiten sichtbar)</li>
                <li>Kp 7-8: Starke Aktivität (Gute Chancen für Polarlichter, eventuell in niedrigen breiten)</li>
                <li>Kp 9: Extreme Aktivität (Sehr hohe Wahrscheinlichkeit für Polarlichter, weltweit sichtbar unter optimalen Bedingungen!)</li>
            </ul>
        </div>
    </div>

    <div class="card" data-chart-type="IMFz">
        <i class="fas fa-magnet icon"></i>
        <h2>Bz-Wert</h2>
        <div class="value-container">
            <span id="bz-value" class="value loading">Lade...</span>
            <span class="unit">nT</span>
        </div>
        <p class="description">Die **Nord-Süd-Komponente** des Interplanetaren Magnetfelds (IMF). Ein negativer Bz-Wert (nach Süden gerichtet) ist entscheidend für das Eintreten von Polarlichtern.</p>
        <canvas id="chartBzSmall"></canvas>
    </div>

    <div class="card" data-chart-type="Speed">
        <i class="fas fa-wind icon"></i>
        <h2>Solarwind - Geschwindigkeit</h2>
        <div class="value-container">
            <span id="solar-wind-speed" class="value loading">Lade...</span>
            <span class="unit">km/s</span>
        </div>
        <p class="description">Die Geschwindigkeit, mit der der Sonnenwind auf das Erdmagnetfeld trifft. Höhere Geschwindigkeiten können die Polarlichtintensität erhöhen.</p>
        <canvas id="chartSpeedSmall"></canvas>
    </div>

    <div class="card" data-chart-type="Density">
        <i class="fas fa-atom icon"></i>
        <h2>Solarwinddichte</h2>
        <div class="value-container">
            <span id="solar-wind-density" class="value loading">Lade...</span>
            <span class="unit">p/cm³</span>
        </div>
        <p class="description">Die Anzahl der Teilchen im Sonnenwind. Eine höhere Dichte liefert mehr Material für die Wechselwirkung mit dem Erdmagnetfeld.</p>
        <canvas id="chartDensitySmall"></canvas>
    </div>

    <div class="card" data-chart-type="IMF">
        <i class="fas fa-solar-panel icon"></i>
        <h2>Bt-Wert (IMF Total)</h2>
        <div class="value-container">
            <span id="bt-value" class="value loading">Lade...</span>
            <span class="unit">nT</span>
        </div>
        <p class="description">Die **Gesamtstärke** des Interplanetaren Magnetfelds (IMF). Ein starkes IMF, besonders bei negativem Bz, kann zu intensiveren Polarlichtern führen.</p>
        <canvas id="chartBtSmall"></canvas>
    </div>

    <div class="card" data-chart-type="DST">
        <i class="fas fa-chart-line icon"></i>
        <h2>DST-Index</h2>
        <div class="value-container">
            <span id="dst-index" class="value loading">Lade...</span>
            <span class="unit">nT</span>
        </div>
        <p class="description">Der Disturbance Storm Time (DST) Index misst die Stärke des äquatorialen Ringstroms. Starke negative Werte deuten auf geomagnetische Stürme hin.</p>
        <canvas id="chartDstSmall"></canvas>
    </div>

    <div class="card">
        <i class="fas fa-chart-area icon"></i>
        <h2>ACE Mag & SWEPAM</h2>
        <div id="ace-mag-swepam-placeholder" class="image-placeholder"
             onclick="showImagePopup('https://services.swpc.noaa.gov/images/ace-mag-swepam-24-hour.gif')"
             style="background-image: url('https://services.swpc.noaa.gov/images/ace-mag-swepam-24-hour.gif');">
        </div>
        <p class="description">Magnetfeld- und Sonnenwinddaten vom ACE-Satelliten der letzten 24 Stunden.</p>
        </div>

    <div class="card">
        <i class="fas fa-chart-pie icon"></i>
        <h2>ACE EPAM</h2>
        <div id="ace-epam-placeholder" class="image-placeholder"
             onclick="showImagePopup('https://services.swpc.noaa.gov/images/ace-epam-3-day.gif')"
             style="background-image: url('https://services.swpc.noaa.gov/images/ace-epam-3-day.gif');">
        </div>
        <p class="description">Elektronen- und Protonenaktivität vom ACE-Satelliten der letzten 3 Tage.</p>
        </div>

    <div class="card">
        <i class="fas fa-wifi icon"></i>
        <h2>D-Region Absorption</h2>
        <div id="dynamicImage2Container" class="image-placeholder"
             onclick="if (document.getElementById('dynamicImage2').src) { showImagePopup(document.getElementById('dynamicImage2').src); }">
            <img id="dynamicImage2" src="" alt="D-Region Absorption" style="display: none;"> <span id="dRegionLoading" style="color: #b0b0b0;">Lade Bild...</span>
        </div>
        <p class="description">Zeigt die Radioabsorptionszone in der D-Region der Ionosphäre, beeinflusst durch Sonnenstrahlung.</p>
        </div>

    <div class="card">
        <i class="fas fa-cloud-sun-rain icon"></i>
        <h2>Aurora Vorhersage (Nord)</h2>
        <div class="image-placeholder"
             onclick="showImagePopup('https://services.swpc.noaa.gov/images/animations/ovation/north/latest.jpg')"
             style="background-image: url('https://services.swpc.noaa.gov/images/animations/ovation/north/latest.jpg');">
        </div>
        <p class="description">Aktuelle Vorhersage der Polarlichtverteilung über der Nordhalbkugel.</p>
    </div>

    <div class="card">
        <i class="fas fa-location-dot icon"></i>
        <h2>Dein Standort</h2>
        <div class="value-container">
            <span id="latitude" class="value loading">Lade...</span>
            <span class="unit">Breitengrad</span>
        </div>
        <div class="value-container">
            <span id="longitude" class="value loading">Lade...</span>
            <span class="unit">Längengrad</span>
        </div>
        <div class="value-container">
            <span id="timezone-name" class="value loading">Lade...</span>
            <span class="unit">Zeitzone</span>
        </div>
        <p class="description">Deine geografischen Koordinaten und die erkannte Zeitzone.</p>
    </div>

    <div class="card">
        <i class="fas fa-sparkles icon"></i>
        <h2>Polarlicht-Wahrscheinlichkeit</h2>
        <div class="value-container">
            <span id="aurora-probability" class="value loading">Lade...</span>
            <span class="unit"></span>
        </div>
        <p class="description">Eine Schätzung der Polarlichtwahrscheinlichkeit basierend auf deinen Koordinaten und aktuellen Weltraumwetterdaten. Beachte: Dies ist nur eine vereinfachte Vorhersage!</p>
    </div>

</div>

<div id="chartModal" class="modal">
    <div class="modal-content">
        <span class="close-button">×</span>
        <h2 id="modalChartTitle"></h2>
        <div class="modal-chart-container">
            <canvas id="modalChart"></canvas>
            <p id="dynamic-utc-notice" class="utc-notice">Lade Zeitzoneninformationen...</p>
        </div>
        <div class="time-selector-container">
            </div>
    </div>
</div>

<div id="image-popup" class="image-popup" onclick="hideImagePopup()">
    <img id="popup-image" src="" alt="Großansicht">
    <iframe id="popup-iframe" src="" frameborder="0" allowfullscreen style="display:none;"></iframe>
</div>

<script>
    // Ermittle die lokale Zeitzone des Browsers
    const userTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    console.log("Erkannte Zeitzone des Nutzers:", userTimeZone);

    // Luxon-Konfiguration für Chart.js
    Chart.defaults.plugins.tooltip.position = 'nearest';
    Chart.defaults.parsing.dateTimeData = {
        parser: function(value) {
            // Die Rohdaten sind UTC, aber wir wollen sie in der lokalen Zeitzone des Nutzers anzeigen
            return luxon.DateTime.fromISO(value, { zone: 'utc' }).setZone(userTimeZone);
        }
    };
    Chart.defaults.scale.time = {
        tooltipFormat: 'dd.MM.yyyy HH:mm:ss',
        displayFormats: {
            minute: 'HH:mm',
            hour: 'HH:mm',
            day: 'dd.MM'
        }
    };

    // --- Globale Variablen für Weltraumwetterdaten ---
    let currentKpIndex = 0;
    let currentBz = 0;
    let currentSolarWindSpeed = 0;
    let currentSolarWindDensity = 0;
    let currentBt = 0;

    // --- Variablen für historische Chart.js Daten (werden durch API-Aufrufe befüllt) ---
    let historicalDataKp = [];
    let historicalDataIMFz = [];
    let historicalDataSpeed = [];
    let historicalDataDensity = [];
    let historicalDataIMF = [];
    let historicalDataDst = [];

    let smallChartInstances = {};
    let currentModalChartType = null;
    let modalChartInstance = null;

    // --- Hilfsfunktion zum Slicen der Daten für einen bestimmten Zeitraum (lokale Zeitzone basierend) oder nach Anzahl ---
    function getSlicedData(sourceData, hours = null, limit = null) {
        if (!sourceData || sourceData.length === 0) return [];

        let filteredData = [...sourceData]; // Create a copy to avoid modifying original array

        // If a limit is provided, take the last 'limit' entries
        if (limit && limit > 0) {
            filteredData = filteredData.slice(-limit);
        } else if (hours !== null) {
            // Otherwise, filter by time, considering the user's local timezone
            const nowInUserTz = luxon.DateTime.now().setZone(userTimeZone);
            const startTimeInUserTz = nowInUserTz.minus({ hours: hours });
            const startTimeUTC = startTimeInUserTz.toUTC(); // Convert back to UTC for comparison with UTC data

            filteredData = sourceData.filter(dp => {
                const dpTimeUTC = luxon.DateTime.fromISO(dp.x, { zone: 'utc' });
                return dpTimeUTC >= startTimeUTC;
            });
        }
        
        // Always sort, even if sliced by limit, to ensure chronological order for charts
        return filteredData.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());
    }

    // --- Funktion zum Abrufen historischer Daten für Charts ---
    async function fetchHistoricalSpaceWeatherData() {
        try {
            // Updated to fetch from rtsw_mag_1m.json for Bz and Bt
            const [responseMag, responseWind, responseKpHistorical, responseDstHistorical] = await Promise.all([
                fetch('https://services.swpc.noaa.gov/json/rtsw/rtsw_mag_1m.json'), // Changed this source
                fetch('https://services.swpc.noaa.gov/json/rtsw/rtsw_wind_1m.json'),
                fetch('https://services.swpc.noaa.gov/json/planetary_k_index_1m.json'),
                fetch('https://services.swpc.noaa.gov/json/geospace/geospace_dst_1_hour.json')
            ]);

            const dataMag = await responseMag.json();
            const dataWind = await responseWind.json();
            const dataKpHistorical = await responseKpHistorical.json();
            const dataDstHistorical = await responseDstHistorical.json();

            // Vorherige historische Daten löschen
            historicalDataKp = [];
            historicalDataIMFz = [];
            historicalDataSpeed = [];
            historicalDataDensity = [];
            historicalDataIMF = [];
            historicalDataDst = [];

            // Kp-Daten verarbeiten
            dataKpHistorical.forEach(item => {
                if (item.kp_index !== null) {
                    historicalDataKp.push({ x: item.time_tag, y: parseFloat(item.kp_index) });
                }
            });
            historicalDataKp.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());

            // Magnetometerdaten (Bz und Bt) verarbeiten
            // Filter nach source: "DSCOVR" (oder "ACE" falls es dort auftaucht)
            dataMag.filter(item => item.source === 'DSCOVR' || item.source === 'ACE').forEach(item => {
                if (item.bz_gsm !== null) historicalDataIMFz.push({ x: item.time_tag, y: parseFloat(item.bz_gsm) });
                if (item.bt !== null) historicalDataIMF.push({ x: item.time_tag, y: parseFloat(item.bt) });
            });
            historicalDataIMFz.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());
            historicalDataIMF.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());

            // Winddaten (Geschwindigkeit und Dichte) verarbeiten
            dataWind.filter(item => item.source === 'DSCOVR').forEach(item => {
                if (item.proton_speed !== null) historicalDataSpeed.push({ x: item.time_tag, y: parseFloat(item.proton_speed) });
                if (item.proton_density !== null) historicalDataDensity.push({ x: item.time_tag, y: parseFloat(item.proton_density) });
            });
            historicalDataSpeed.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());
            historicalDataDensity.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());

            // DST-Daten verarbeiten
            dataDstHistorical.forEach(item => {
                if (item.dst !== null) {
                    historicalDataDst.push({ x: item.time_tag, y: parseFloat(item.dst) });
                }
            });
            historicalDataDst.sort((a, b) => luxon.DateTime.fromISO(a.x, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(b.x, { zone: 'utc' }).toMillis());

            renderSmallCharts();

        } catch (error) {
            console.error('Fehler beim Abrufen historischer Daten:', error);
        }
    }

    // --- Kleine Chart-Rendering-Funktion ---
    function renderSmallCharts() {
        for (const chartId in smallChartInstances) {
            if (smallChartInstances[chartId]) smallChartInstances[chartId].destroy();
        }
        smallChartInstances = {};

        const commonChartOptions = (specificTimeUnit = 'hour') => ({
            responsive: true,
            plugins: { legend: { display: false } },
            scales: {
                x: {
                    type: 'time',
                    time: {
                        unit: specificTimeUnit,
                        tooltipFormat: 'dd.MM.yyyy HH:mm:ss',
                        displayFormats: {
                            minute: 'HH:mm',
                            hour: 'HH:mm',
                            day: 'dd.MM'
                        }
                    },
                    adapters: {
                        date: {
                            zone: userTimeZone // Angepasst an die lokale Zeitzone des Nutzers
                        }
                    },
                    ticks: { color: '#888', maxRotation: 0, autoSkipPadding: 10, source: 'auto', maxTicksLimit: 6 },
                    grid: { color: 'rgba(255,255,255,0.05)' }
                },
                y: {
                    ticks: { color: '#888' },
                    grid: { color: 'rgba(255,255,255,0.05)' }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            if (context[0] && context[0].parsed && context[0].parsed.x) {
                                return luxon.DateTime.fromMillis(context[0].parsed.x, { zone: userTimeZone }).toLocaleString(luxon.DateTime.DATETIME_SHORT_WITH_SECONDS);
                            }
                            return '';
                        },
                        label: function(context) {
                            let lbl = context.dataset.label || '';
                            if (lbl) lbl += ': ';
                            if (context.parsed.y !== null) {
                                lbl += context.parsed.y.toFixed(2);
                                if (context.dataset.label === 'Bz-Wert' || context.dataset.label === 'IMF total field' || context.dataset.label === 'DST-Index') lbl += ' nT';
                                else if (context.dataset.label === 'Geschwindigkeit') lbl += ' km/s';
                                else if (context.dataset.label === 'Dichte') lbl += ' p/cm³';
                            }
                            return lbl;
                        }
                    }
                }
            }
        });

        const chartConfigs = {
            'chartKpSmall': { label: 'Kp-Index', data: getSlicedData(historicalDataKp, 3), color: '#00bcd4', timeUnit: 'minute' },
            'chartBzSmall': { label: 'Bz-Wert', data: getSlicedData(historicalDataIMFz, 3), color: '#ff9800', timeUnit: 'minute' },
            'chartSpeedSmall': { label: 'Geschwindigkeit', data: getSlicedData(historicalDataSpeed, 3), color: '#4caf50', timeUnit: 'minute' },
            'chartDensitySmall': { label: 'Dichte', data: getSlicedData(historicalDataDensity, 3), color: '#e57373', timeUnit: 'minute' },
            'chartBtSmall': { label: 'Bt-Wert', data: getSlicedData(historicalDataIMF, 3), color: '#2196f3', timeUnit: 'minute' },
            'chartDstSmall': { label: 'DST-Index', data: getSlicedData(historicalDataDst, 3), color: '#f44336', timeUnit: 'minute' },
        };

        for (const id in chartConfigs) {
            const ctx = document.getElementById(id);
            if (ctx) {
                const config = chartConfigs[id];
                const chartData = {
                    datasets: [{
                        label: config.label,
                        data: config.data,
                        borderColor: config.color,
                        backgroundColor: 'transparent',
                        tension: 0.3,
                        pointRadius: 0
                    }]
                };
                let options = commonChartOptions(config.timeUnit || 'hour');

                if (config.isSinglePoint) {
                    options.scales.x = {
                        type: 'category',
                        labels: config.data.map(dp => luxon.DateTime.fromISO(dp.x, { zone: 'utc' }).setZone(userTimeZone).toFormat('HH:mm')),
                        ticks: { color: '#888'},
                        grid: {display: false}
                    };
                    chartData.datasets[0].pointRadius = 3;
                }

                smallChartInstances[id] = new Chart(ctx, { type: 'line', data: chartData, options: options });
            }
        }
    }

    // --- Abrufen und Aktualisieren der aktuellen Echtzeitdaten ---
    async function fetchSpaceWeatherData() {
        try {
            // Updated to fetch from rtsw_mag_1m.json for current Bz and Bt
            const [
                resKp, resWind, resMag, resDst
            ] = await Promise.all([
                fetch('https://services.swpc.noaa.gov/json/planetary_k_index_1m.json'),
                fetch('https://services.swpc.noaa.gov/json/rtsw/rtsw_wind_1m.json'),
                fetch('https://services.swpc.noaa.gov/json/rtsw/rtsw_mag_1m.json'), // Changed this source
                fetch('https://services.swpc.noaa.gov/json/geospace/geospace_dst_1_hour.json'),
            ]);

            const dataKp = await resKp.json();
            const dataWind = await resWind.json();
            const dataMag = await resMag.json(); // Data from rtsw_mag_1m.json
            const dataDst = await resDst.json();

            // Kp Index - Neueste ist oft am Ende des Arrays
            const latestKpData = dataKp[dataKp.length - 1];
            currentKpIndex = latestKpData && latestKpData.kp_index !== null ? parseFloat(latestKpData.kp_index) : 0;
            document.getElementById('kp-index').textContent = latestKpData ? currentKpIndex.toFixed(1) : 'N/A';

            // Solar Wind Speed & Density
            const latestWindData = dataWind.filter(item => item.source === 'DSCOVR' && item.proton_speed !== null && item.proton_density !== null)
                                            .sort((a,b) => luxon.DateTime.fromISO(b.time_tag, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(a.time_tag, { zone: 'utc' }).toMillis())[0];
            currentSolarWindSpeed = latestWindData ? parseFloat(latestWindData.proton_speed) : 0;
            currentSolarWindDensity = latestWindData ? parseFloat(latestWindData.proton_density) : 0;
            document.getElementById('solar-wind-speed').textContent = latestWindData ? currentSolarWindSpeed.toFixed(0) : 'N/A';
            document.getElementById('solar-wind-density').textContent = latestWindData ? currentSolarWindDensity.toFixed(2) : 'N/A';

            // Bz & Bt from rtsw_mag_1m.json (filter by source and get latest)
            // Sort to get the most recent data point from DSCOVR or ACE
            const latestMagData = dataMag.filter(item => item.source === 'DSCOVR' || item.source === 'ACE')
                                         .sort((a,b) => luxon.DateTime.fromISO(b.time_tag, { zone: 'utc' }).toMillis() - luxon.DateTime.fromISO(a.time_tag, { zone: 'utc' }).toMillis())[0];

            currentBz = latestMagData && latestMagData.bz_gsm !== null ? parseFloat(latestMagData.bz_gsm) : 0;
            currentBt = latestMagData && latestMagData.bt !== null ? parseFloat(latestMagData.bt) : 0;
            document.getElementById('bz-value').textContent = latestMagData ? currentBz.toFixed(2) : 'N/A';
            document.getElementById('bt-value').textContent = latestMagData ? currentBt.toFixed(2) : 'N/A';

            // DST Index (most recent is usually at index 0)
            const latestDstData = dataDst[0];
            document.getElementById('dst-index').textContent = latestDstData && latestDstData.dst !== null ? parseFloat(latestDstData.dst).toFixed(2) : 'N/A';

            // Alle "Lade..."-Texte entfernen und ggf. Fehlertexte zurücksetzen
            document.querySelectorAll('.value.loading').forEach(element => {
                element.classList.remove('loading');
            });
            document.querySelectorAll('.value-container .error').forEach(element => {
                element.classList.remove('error');
            });

        } catch (error) {
            console.error('Fehler beim Abrufen der aktuellen Daten:', error);
            document.querySelectorAll('.value').forEach(element => {
                if (element.classList.contains('loading')) {
                    element.textContent = 'Fehler!';
                    element.classList.remove('loading');
                    element.classList.add('error');
                }
            });
        }
    }

    // --- Geolocation und Polarlichtwahrscheinlichkeit ---
    async function getLocationAndCalculateAuroraProbability() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(async position => {
                const latitude = position.coords.latitude;
                const longitude = position.coords.longitude;

                document.getElementById('latitude').textContent = latitude.toFixed(2);
                document.getElementById('longitude').textContent = longitude.toFixed(2);
                document.getElementById('timezone-name').textContent = userTimeZone; // Zeitzone anzeigen

                updateAuroraProbability(latitude);
                document.getElementById('latitude').classList.remove('loading');
                document.getElementById('longitude').classList.remove('loading');
                document.getElementById('timezone-name').classList.remove('loading');
                document.getElementById('aurora-probability').classList.remove('loading');
            }, error => {
                console.error("Fehler bei der Standortbestimmung:", error);
                document.getElementById('latitude').textContent = 'Nicht verfügbar';
                document.getElementById('longitude').textContent = 'Nicht verfügbar';
                document.getElementById('timezone-name').textContent = 'Nicht verfügbar';
                document.getElementById('aurora-probability').textContent = 'Nicht verfügbar';
                ['latitude', 'longitude', 'timezone-name', 'aurora-probability'].forEach(id => {
                    document.getElementById(id).classList.remove('loading');
                    document.getElementById(id).classList.add('error');
                });
            });
        } else {
            console.error("Geolocation wird von diesem Browser nicht unterstützt.");
            ['latitude', 'longitude', 'timezone-name', 'aurora-probability'].forEach(id => {
                document.getElementById(id).textContent = 'Nicht unterstützt';
                document.getElementById(id).classList.remove('loading');
                document.getElementById(id).classList.add('error');
            });
        }
    }

    function updateAuroraProbability(latitude) {
        if (latitude === undefined || currentKpIndex === undefined || currentBz === undefined || currentSolarWindSpeed === undefined || currentSolarWindDensity === undefined || currentBt === undefined) {
            document.getElementById('aurora-probability').textContent = 'Daten fehlen';
            document.getElementById('aurora-probability').classList.add('error');
            return;
        }

        let probability = 0;

        if (latitude > 70) probability += 20;
        else if (latitude > 65) probability += 10;
        else if (latitude > 60) probability += 5;
        else probability -= 15;
        probability = Math.max(0, probability);

        if (currentKpIndex >= 5) probability += (currentKpIndex - 4) * 10;
        else if (currentKpIndex >= 3) probability += (currentKpIndex - 2) * 3;

        if (currentBz < -15) probability += 20;
        else if (currentBz < -10) probability += 10;
        else if (currentBz < -5) probability += 5;

        if (currentSolarWindSpeed > 700) probability += 10;
        else if (currentSolarWindSpeed > 600) probability += 5;
        else if (currentSolarWindSpeed > 500) probability += 2;

        if (currentSolarWindDensity > 30) probability += 3;
        else if (currentSolarWindDensity > 20) probability += 1;

        if (currentBt > 20) probability += 2;
        else if (currentBt > 15) probability += 1;

        probability = Math.max(0, Math.min(100, probability));
        document.getElementById('aurora-probability').textContent = probability.toFixed(0) + '%';
        document.getElementById('aurora-probability').classList.remove('loading', 'error');
    }

    // --- Dynamische Bildaktualisierungen (D-Region) ---
    function updateDRegionImage() {
        const jsonUrl = 'https://services.swpc.noaa.gov/products/animations/d-rap_global.json';
        const baseUrl = 'https://services.swpc.noaa.gov';
        const imgElement = document.getElementById('dynamicImage2');
        const placeholderDiv = document.getElementById('dynamicImage2Container');
        const loadingSpan = document.getElementById('dRegionLoading');

        imgElement.style.display = 'none';
        loadingSpan.style.display = 'block';

        fetch(jsonUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                let imageUrl;
                if (Array.isArray(data) && data.length > 0) {
                    imageUrl = baseUrl + data[data.length - 1].url;
                    imgElement.onload = () => {
                        imgElement.style.display = 'block';
                        loadingSpan.style.display = 'none';
                    };
                    imgElement.onerror = () => {
                        imgElement.style.display = 'none';
                        loadingSpan.textContent = 'Bild Ladefehler';
                    };
                    imgElement.src = imageUrl;
                } else {
                    console.error("JSON-Struktur für D-Region Bild nicht erkannt oder leer.");
                    imgElement.style.display = 'none';
                    loadingSpan.textContent = 'Bild nicht verfügbar';
                }
            })
            .catch(error => {
                console.error("Fehler beim Abrufen der JSON-Datei für D-Region Bild:", error);
                imgElement.style.display = 'none';
                loadingSpan.textContent = 'Bild Ladefehler';
            });
    }

    // --- Kp-Info Umschalter ---
    function toggleKpInfo(event) {
        event.stopPropagation();
        const kpInfoDiv = document.getElementById('kp-info');
        kpInfoDiv.style.display = (kpInfoDiv.style.display === 'none' || kpInfoDiv.style.display === '') ? 'block' : 'none';
    }

    // --- Bild-Popup für Großansichten ---
    function showImagePopup(mediaUrl) {
        const popup = document.getElementById('image-popup');
        const popupImage = document.getElementById('popup-image');
        const popupIframe = document.getElementById('popup-iframe');

        popupImage.style.display = 'none';
        popupIframe.style.display = 'none';

        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif'];
        const isImage = imageExtensions.some(ext => mediaUrl.toLowerCase().endsWith(ext));

        if (isImage) {
            popupImage.src = mediaUrl;
            popupImage.alt = "Großansicht";
            popupImage.style.display = 'block';
        } else {
            popupIframe.src = mediaUrl;
            popupIframe.style.display = 'block';
        }
        popup.style.display = 'flex';
    }

    function hideImagePopup() {
        const popup = document.getElementById('image-popup');
        popup.style.display = 'none';
        document.getElementById('popup-image').src = '';
        document.getElementById('popup-iframe').src = '';
    }

    // --- Modal Chart Funktionalität ---
    const chartModal = document.getElementById('chartModal');
    const closeButton = chartModal.querySelector('.close-button');
    const modalChartCanvas = document.getElementById('modalChart');
    const modalChartTitle = document.getElementById('modalChartTitle');
    const dynamicUtcNotice = document.getElementById('dynamic-utc-notice'); // Das neue Element

    document.querySelectorAll('.card[data-chart-type]').forEach(card => {
        card.addEventListener('click', function(event) {
            if (event.target.classList.contains('kp-info-button')) {
                return;
            }
            currentModalChartType = this.dataset.chartType;
            const title = this.querySelector('h2').textContent;
            modalChartTitle.textContent = title;
            chartModal.style.display = 'flex';
            // For DST, pass the limit parameter
            if (currentModalChartType === 'DST') {
                renderModalChart('50_values'); // Custom period string to indicate "last 50 values"
            } else {
                renderModalChart('3h'); // Default for other charts
            }
            updateDynamicUtcNotice(); // Notiz beim Öffnen des Modals aktualisieren
        });
    });

    closeButton.addEventListener('click', function() {
        chartModal.style.display = 'none';
        if (modalChartInstance) {
            modalChartInstance.destroy();
            modalChartInstance = null;
        }
    });

    window.addEventListener('click', function(event) {
        if (event.target == chartModal) {
            chartModal.style.display = 'none';
            if (modalChartInstance) {
                modalChartInstance.destroy();
                modalChartInstance = null;
            }
        }
    });

    function renderModalChart(period) {
        let chartData, chartLabel, color, valueSuffix = '', timeUnit = 'hour'; // Default to hour for modal charts
        let limit = null;
        let hours = null;

        if (period === '50_values') {
            limit = 50;
        } else {
            hours = parseInt(period.replace('h', ''));
        }

        let sourceFullData;

        switch(currentModalChartType) {
            case 'Kp':
                sourceFullData = historicalDataKp; chartLabel = 'Kp-Index'; color = '#00bcd4'; timeUnit = 'minute';
                break;
            case 'IMFz':
                sourceFullData = historicalDataIMFz; chartLabel = 'Bz-Wert'; color = '#ff9800'; valueSuffix = ' nT'; timeUnit = 'minute';
                break;
            case 'Speed':
                sourceFullData = historicalDataSpeed; chartLabel = 'Solarwindgeschwindigkeit'; color = '#4caf50'; valueSuffix = ' km/s'; timeUnit = 'minute';
                break;
            case 'Density':
                sourceFullData = historicalDataDensity; chartLabel = 'Solarwinddichte'; color = '#e57373'; valueSuffix = ' p/cm³'; timeUnit = 'minute';
                break;
            case 'IMF':
                sourceFullData = historicalDataIMF; chartLabel = 'Bt-Wert'; color = '#2196f3'; valueSuffix = ' nT'; timeUnit = 'minute';
                break;
            case 'DST':
                sourceFullData = historicalDataDst; chartLabel = 'DST-Index'; color = '#f44336'; valueSuffix = ' nT'; timeUnit = 'hour'; // DST is hourly data
                break;
            default: return;
        }

        chartData = getSlicedData(sourceFullData, hours, limit);

        if (modalChartInstance) {
            modalChartInstance.data.datasets[0].data = chartData;
            modalChartInstance.options.scales.x.time.unit = timeUnit;
            // If the time unit changes, it's often better to redraw the chart fully for scale formatting
            modalChartInstance.destroy();
            modalChartInstance = null; // Set to null so the new chart is created below
        }

        if (!modalChartInstance) {
            let xAxisTicksConfig = {
                color: '#b0b0b0',
                source: 'auto',
                maxRotation: 0,
                autoSkipPadding: 15,
                major: { enabled: true }
            };

            let yAxisConfig = {
                ticks: { color: '#b0b0b0' },
                grid: { color: 'rgba(255,255,255,0.1)' }
            };

            modalChartInstance = new Chart(modalChartCanvas, {
                type: 'line',
                data: {
                    datasets: [{
                        label: chartLabel,
                        data: chartData,
                        borderColor: color,
                        backgroundColor: 'rgba(0,0,0,0)',
                        tension: 0.3,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, labels: { color: '#e0e0e0' } },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    if (context[0] && context[0].parsed && context[0].parsed.x) {
                                        // Luxon kann direkt in der userTimeZone formatieren
                                        return luxon.DateTime.fromMillis(context[0].parsed.x, { zone: userTimeZone }).toLocaleString(luxon.DateTime.DATETIME_SHORT_WITH_SECONDS);
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    let lbl = context.dataset.label || '';
                                    if (lbl) lbl += ': ';
                                    if (context.parsed.y !== null) {
                                        lbl += context.parsed.y.toFixed(2) + valueSuffix;
                                    }
                                    return lbl;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: timeUnit,
                                tooltipFormat: 'dd.MM.yyyy HH:mm:ss',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm',
                                    day: 'dd.MM HH:mm'
                                }
                            },
                            adapters: {
                                date: {
                                    zone: userTimeZone // Angepasst an die lokale Zeitzone des Nutzers
                                }
                            },
                            ticks: xAxisTicksConfig,
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: yAxisConfig
                    }
                }
            });
        }
    }

    // Funktion zur dynamischen Aktualisierung der Zeitzonen-Notiz
    function updateDynamicUtcNotice() {
        const now = luxon.DateTime.now();
        const utcNow = luxon.DateTime.now().setZone('utc');
        const userLocalTime = now.setZone(userTimeZone); // Zeit in der lokalen Zeitzone des Nutzers

        // Differenz in Millisekunden
        const diffMillis = userLocalTime.diff(utcNow).toMillis();
        // Differenz in Stunden
        const diffHours = diffMillis / (1000 * 60 * 60);

        let sign = '';
        let hours = Math.abs(Math.floor(diffHours)); // Ganze Stunden
        let minutes = Math.round((Math.abs(diffHours) - hours) * 60); // Gerundete Minuten

        if (diffHours > 0) {
            sign = '+';
        } else if (diffHours < 0) {
            sign = '-';
        } else {
            dynamicUtcNotice.textContent = `Die Zeitangaben in diesen Grafiken sind in UTC (Ihre Zeitzone "${userTimeZone}" ist UTC-gleich).`;
            return;
        }

        let timeOffsetString;
        if (minutes === 0) {
            timeOffsetString = `${sign}${hours} Stunde${hours !== 1 ? 'n' : ''}`;
        } else {
            timeOffsetString = `${sign}${hours} Stunde${hours !== 1 ? 'n' : ''} und ${minutes} Minute${minutes !== 1 ? 'n' : ''}`;
        }

        dynamicUtcNotice.textContent = `Bitte beachten Sie: Die Zeitangaben in diesen Grafiken sind in UTC. Um die Zeit in Ihrer lokalen Zeitzone ("${userTimeZone}") zu erhalten, müssen Sie ${sign} ${hours} Stunde${hours !== 1 ? 'n' : ''} und ${minutes} Minute${minutes !== 1 ? 'n' : ''} (UTC${sign}${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}) ${diffHours > 0 ? 'hinzurechnen' : 'abziehen'}.`;
    }


    // --- Initialaufrufe und Intervalle ---
    window.addEventListener('load', () => {
        getLocationAndCalculateAuroraProbability();
        fetchSpaceWeatherData();
        fetchHistoricalSpaceWeatherData();
        updateDRegionImage();
        // Die Zeitzonen-Notiz direkt beim Laden initialisieren
        updateDynamicUtcNotice(); 
    });

    setInterval(fetchSpaceWeatherData, 60000); // Every minute for current values
    setInterval(fetchHistoricalSpaceWeatherData, 5 * 60 * 1000); // Every 5 minutes for historical data/charts
    setInterval(updateDRegionImage, 60 * 1000); // Update D-Region image every minute
    // Optional: Aktualisieren Sie die Zeitzonen-Notiz stündlich, falls sich der Offset durch Sommerzeit ändert (eher selten in einer laufenden Session, aber gut für den nächsten Tag)
    setInterval(updateDynamicUtcNotice, 60 * 60 * 1000); 
</script>
</body>
</html>
